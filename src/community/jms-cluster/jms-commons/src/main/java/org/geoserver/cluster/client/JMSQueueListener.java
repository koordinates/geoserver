/* (c) 2014 Open Source Geospatial Foundation - all rights reserved
 * (c) 2001 - 2013 OpenPlans
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.cluster.client;

import static java.lang.String.format;
import static org.geoserver.cluster.configuration.JMSConfiguration.GROUP_KEY;
import static org.geoserver.cluster.configuration.JMSConfiguration.INSTANCE_NAME_KEY;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import org.geoserver.cluster.JMSApplicationListener;
import org.geoserver.cluster.JMSEventHandler;
import org.geoserver.cluster.JMSEventHandlerSPI;
import org.geoserver.cluster.JMSManager;
import org.geoserver.cluster.events.ToggleType;
import org.geotools.util.logging.Logging;
import org.springframework.jms.listener.SessionAwareMessageListener;

/**
 * JMS Client (Consumer)
 *
 * <p>Class which leverages on commons classes to define a Topic consumer handling incoming messages
 * using runtime loaded SPI to instantiate needed handlers.
 *
 * @see {@link JMSManager}
 * @author Carlo Cancellieri - carlo.cancellieri@geo-solutions.it
 */
public class JMSQueueListener extends JMSApplicationListener
        implements SessionAwareMessageListener<Message> {

    private static final java.util.logging.Logger LOGGER =
            Logging.getLogger(JMSQueueListener.class);

    private final JMSManager jmsManager;

    public JMSQueueListener(final JMSManager jmsManager) {
        super(ToggleType.SLAVE);
        this.jmsManager = jmsManager;
    }

    private AtomicLong consumedEvents = new AtomicLong();

    @Override
    public void onMessage(Message message, Session session) throws JMSException {
        fine("Incoming message event for session: %s", session.toString());

        // CHECKING LISTENER STATUS
        if (!isEnabled()) {
            fine("Incoming message is swallowed since this component is disabled");
            return;
        }
        // FILTERING INCOMING MESSAGE
        if (!message.propertyExists(INSTANCE_NAME_KEY)) {
            throwJMSException(
                    "Unable to handle incoming message, property '%s' not set.", INSTANCE_NAME_KEY);
        }

        // FILTERING INCOMING MESSAGE
        if (!message.propertyExists(GROUP_KEY)) {
            throwJMSException(
                    "Unable to handle incoming message, property '%s' not set.", GROUP_KEY);
        }

        // check if message comes from a master with the same name of this slave
        if (message.getStringProperty(INSTANCE_NAME_KEY)
                .equals(config.getConfiguration(INSTANCE_NAME_KEY))) {
            fine("Incoming message discarded: source is equal to destination");
            // if so discard the message
            return;
        }

        // check if message comes from a different group
        final String group = message.getStringProperty(GROUP_KEY);
        final String localGroup = config.getConfiguration(GROUP_KEY);
        if (!group.equals(localGroup)) {
            fine(
                    "Incoming message discarded: incoming group--> %s is different from the local one--> %s",
                    group, localGroup);
            // if so discard the message
            return;
        }

        // check the property which define the SPI used (to serialize on the
        // server side).
        if (!message.propertyExists(JMSEventHandlerSPI.getKeyName()))
            throwJMSException(
                    "Unable to handle incoming message, property '%s' not set.",
                    JMSEventHandlerSPI.getKeyName());

        // END -> FILTERING INCOMING MESSAGE

        // get the name of the SPI used to serialize the message
        final String generatorClass = message.getStringProperty(JMSEventHandlerSPI.getKeyName());
        if (generatorClass == null || generatorClass.isEmpty()) {
            throw new IllegalArgumentException(
                    "Unable to handle a message without a generator class name");
        }
        fine("Incoming message was serialized using an handler generated by: '%s'", generatorClass);

        if (!(message instanceof ObjectMessage)) {
            throw new JMSException("Unrecognized message type for catalog incoming event");
        }

        // USING INCOMING MESSAGE
        final ObjectMessage objMessage = (ObjectMessage) (message);
        final Serializable obj = objMessage.getObject();
        // lookup the SPI handler, search is performed using the
        // name
        final JMSEventHandler<Serializable, Object> handler =
                jmsManager.getHandlerByClassName(generatorClass);
        if (handler == null) {
            consumedEvents.incrementAndGet();
            throwJMSException(
                    "Unable to find SPI named '%s', be shure to load that SPI into your context.",
                    generatorClass);
        }

        final Properties options = getMessageProperties(message);
        handler.setProperties(options);

        Object deserializedObject;
        try {
            // try to synchronize object locally
            deserializedObject = handler.deserialize(obj);
        } catch (Exception e) {
            this.consumedEvents.incrementAndGet();
            final JMSException jmsE = new JMSException(e.getLocalizedMessage());
            jmsE.initCause(e);
            throw jmsE;
        }
        try {
            if (!handler.synchronize(deserializedObject)) {
                throwJMSException("Unable to synchronize message locally. SPI: %s", generatorClass);
            }
        } catch (JMSException e) {
            throw e;
        } catch (Exception e) {
            LOGGER.log(
                    Level.SEVERE,
                    handler.getClass().getName()
                            + " error synchronizing incoming event: "
                            + deserializedObject,
                    e);
        } finally {
            this.consumedEvents.incrementAndGet();
        }
    }

    private Properties getMessageProperties(Message message) throws JMSException {
        @SuppressWarnings("unchecked")
        final Enumeration<String> keys = message.getPropertyNames();
        final Properties options = new Properties();
        while (keys.hasMoreElements()) {
            String key = keys.nextElement();
            options.put(key, message.getObjectProperty(key));
        }
        return options;
    }

    // /**
    // * @deprecated unused/untested
    // * @param message
    // * @throws JMSException
    // */
    // private static void getStreamMessage(Message message) throws JMSException
    // {
    // if (message instanceof StreamMessage) {
    // StreamMessage streamMessage = StreamMessage.class.cast(message);
    //
    // File file;
    // // FILTERING incoming message
    // // if (!message.propertyExists(JMSEventType.FILENAME_KEY))
    // // throw new JMSException(
    // // "Unable to handle incoming message, property \'"
    // // + JMSEventType.FILENAME_KEY + "\' not set.");
    //
    // FileOutputStream fos = null;
    // try {
    // file = new File(GeoserverDataDirectory
    // .getGeoserverDataDirectory().getCanonicalPath(), "");
    // // TODO get file name
    // // message.getStringProperty(JMSEventType.FILENAME_KEY));
    // fos = new FileOutputStream(file);
    // final int size = 1024;
    // final byte[] buf = new byte[size];
    // int read = 0;
    // streamMessage.reset();
    // while ((read = streamMessage.readBytes(buf)) != -1) {
    // fos.write(buf, 0, read);
    // fos.flush();
    // }
    // } catch (IOException e) {
    // if (LOGGER.isErrorEnabled()) {
    // LOGGER.error(e.getLocalizedMessage(), e);
    // }
    // throw new JMSException(e.getLocalizedMessage());
    // } catch (JMSException e) {
    // if (LOGGER.isErrorEnabled()) {
    // LOGGER.error(e.getLocalizedMessage(), e);
    // }
    // throw new JMSException(e.getLocalizedMessage());
    // } finally {
    // IOUtils.closeQuietly(fos);
    // }
    //
    // } else
    // throw new JMSException(
    // "Unrecognized message type for catalog incoming event");
    // }

    public long getConsumedEvents() {
        return consumedEvents.get();
    }

    public void resetconsumedevents() {
        consumedEvents.set(0);
    }

    private void throwJMSException(String msgFormat, Object... args) throws JMSException {
        throw new JMSException(format(msgFormat, args));
    }

    private void fine(String msgFormat, Object... args) {
        log(Level.FINE, msgFormat, args);
    }

    private void log(Level level, String msgFormat, Object... args) {
        if (LOGGER.isLoggable(level)) {
            String msg = String.format(msgFormat, args);
            LOGGER.log(level, msg);
        }
    }
}
